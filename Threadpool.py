# -*- coding: utf-8 -*-
"""OS Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pQqGJq9TW6kaiQpyK2ODCYvcmWT5Lm-y
"""

#Thread Pools
#Reusing existing threads, because creating threads are expensive

#Imports
import logging
import threading
from concurrent.futures import ThreadPoolExecutor #Python 3.2
import time
import random

#Test function
def test(item):
    s = random.randrange(1,10)
    logging.info(f'Task {item + 1}: id = {threading.get_ident()}')
    logging.info(f'Task {item + 1}: name = {threading.current_thread().name}')
    logging.info(f'Thread {item}: Works for {s}s')
    time.sleep(s)
    logging.info(f'Task {item + 1}: finished')

#Main function
def main():
    logging.basicConfig(format='%(levelname)s - %(asctime)s: %(message)s',datefmt='%H:%M:%S', level=logging.DEBUG)
    logging.info('App Start')

    threads = int(input("Enter the number of threads needed : "))
    tasks = int(input("Enter the number of tasks to be performed : "))

    with ThreadPoolExecutor(max_workers=threads) as executor:
        executor.map(test,range(tasks))

    logging.info('App Finished')


if __name__ == "__main__":
    main()



